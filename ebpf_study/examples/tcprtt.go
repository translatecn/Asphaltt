// This program demonstrates attaching a fentry eBPF program to
// tcp_close and reading the RTT from the TCP socket using CO-RE helpers.
// It prints the IPs/ports/RTT information
// once the host closes a TCP connection.
// It supports only IPv4 for this example.
//
// Sample output:
//
// examples# go run -exec sudo ./tcprtt
// 2022/03/19 22:30:34 Src addr        Port   -> Dest addr       Port   RTT
// 2022/03/19 22:30:36 10.0.1.205      50578  -> 117.102.109.186 5201   195
// 2022/03/19 22:30:53 10.0.1.205      0      -> 89.84.1.178     9200   30
// 2022/03/19 22:30:53 10.0.1.205      36022  -> 89.84.1.178     9200   28

// This program demonstrates attaching an eBPF program to
// a cgroupv2 path and using sockops to process TCP socket events.
// It prints the IPs/ports/RTT information every time TCP sockets
// update their internal RTT value.
// It supports only IPv4 for this example.
//
// Sample output:
//
// examples# go run -exec sudo ./tcprtt_sockops
// 2022/08/14 20:58:03 eBPF program loaded and attached on cgroup /sys/fs/cgroup/unified
// 2022/08/14 20:58:03 Src addr        Port   -> Dest addr       Port   RTT (ms)
// 2022/08/14 20:58:09 10.0.1.205      54844  -> 20.42.73.25     443    67
// 2022/08/14 20:58:09 10.0.1.205      54844  -> 20.42.73.25     443    67
// 2022/08/14 20:58:33 10.0.1.205      38620  -> 140.82.121.4    443    26
// 2022/08/14 20:58:33 10.0.1.205      38620  -> 140.82.121.4    443    26
// 2022/08/14 20:58:43 34.67.40.146    45380  -> 10.0.1.205      5201   106
// 2022/08/14 20:58:43 34.67.40.146    45380  -> 10.0.1.205      5201   106

package examples

//func main4() {
//	stopper := make(chan os.Signal, 1)
//	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)
//
//	// Allow the current process to lock memory for eBPF resources.
//	if err := rlimit.RemoveMemlock(); err != nil {
//		log.Fatal(err)
//	}
//
//	// Load pre-compiled programs and maps into the kernel.
//	objs := bpf.TCPRTTObjects{}
//	if err := bpf.LoadTCPRTTObjects(&objs, nil); err != nil {
//		log.Fatalf("loading objects: %v", err)
//	}
//	defer objs.Close()
//
//	link, err := link.AttachTracing(link.TracingOptions{
//		Program: objs.TCPRTTPrograms.TcpClose,
//	})
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer link.Close()
//
//	rd, err := ringbuf.NewReader(objs.TCPRTTMaps.Events)
//	if err != nil {
//		log.Fatalf("opening ringbuf reader: %s", err)
//	}
//	defer rd.Close()
//
//	log.Printf("%-15s %-6s -> %-15s %-6s %-6s",
//		"Src addr",
//		"Port",
//		"Dest addr",
//		"Port",
//		"RTT",
//	)
//	go readLoop(rd)
//
//	// Wait
//	<-stopper
//}
//
//func readLoop(rd *ringbuf.Reader) {
//	// bpfEvent is generated by bpf2go.
//	var event bpf.TCPRTTEvent
//	for {
//		record, err := rd.Read()
//		if err != nil {
//			if errors.Is(err, ringbuf.ErrClosed) {
//				log.Println("received signal, exiting..")
//				return
//			}
//			log.Printf("reading from reader: %s", err)
//			continue
//		}
//
//		// Parse the ringbuf event entry into a bpfEvent structure.
//		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.NativeEndian, &event); err != nil {
//			log.Printf("parsing ringbuf event: %s", err)
//			continue
//		}
//
//		log.Printf("%-15s %-6d -> %-15s %-6d %-6d",
//			intToIP(event.Saddr),
//			event.Sport,
//			intToIP(event.Daddr),
//			event.Dport,
//			event.Srtt,
//		)
//	}
//}
//
//func findCgroupPath() (string, error) {
//	cgroupPath := "/sys/fs/cgroup"
//
//	var st syscall.Statfs_t
//	err := syscall.Statfs(cgroupPath, &st)
//	if err != nil {
//		return "", err
//	}
//	isCgroupV2Enabled := st.Type == unix.CGROUP2_SUPER_MAGIC
//	if !isCgroupV2Enabled {
//		cgroupPath = filepath.Join(cgroupPath, "unified")
//	}
//	return cgroupPath, nil
//}
//
//type rttEvent struct {
//	Sport uint16
//	Dport uint16
//	Saddr uint32
//	Daddr uint32
//	Srtt  uint32
//}
//
//func main11() {
//	stopper := make(chan os.Signal, 1)
//	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)
//
//	// Allow the current process to lock memory for eBPF resources.
//	if err := rlimit.RemoveMemlock(); err != nil {
//		log.Fatal(err)
//	}
//
//	// Find the path to a cgroup enabled to version 2
//	cgroupPath, err := findCgroupPath()
//	if err != nil {
//		log.Fatal(err)
//	}
//
//	// Attach ebpf program to a cgroupv2
//	link, err := link.AttachCgroup(link.CgroupOptions{
//		Path:    cgroupPath,
//		Program: objs.tcprttPrograms.BpfSockopsCb,
//		Attach:  ebpf.AttachCGroupSockOps,
//	})
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer link.Close()
//
//	log.Printf("eBPF program loaded and attached on cgroup %s\n", cgroupPath)
//
//	rd, err := ringbuf.NewReader(objs.tcprttMaps.RttEvents)
//	if err != nil {
//		log.Fatalf("opening ringbuf reader: %s", err)
//	}
//	defer rd.Close()
//
//	log.Printf("%-15s %-6s -> %-15s %-6s %-6s",
//		"Src addr",
//		"Port",
//		"Dest addr",
//		"Port",
//		"RTT (ms)",
//	)
//	go readLoop(rd)
//
//	<-stopper
//}
